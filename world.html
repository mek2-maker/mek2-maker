<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>인터랙티브 3D 지구본 (국가명 부분 검색 지원)</title>
  <!-- 임시 CSP: 개발 시 unsafe-inline 허용 (운영 환경에서는 nonce나 해시 사용 권장) -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      max-width: 300px;
    }
    #results {
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
    }
    .result-item {
      padding: 5px;
      border-bottom: 1px solid #ccc;
      cursor: pointer;
    }
    .result-item:hover {
      background-color: #eee;
    }
  </style>
</head>
<body>
  <!-- 사용자 인터페이스 -->
  <div id="overlay">
    <label for="iso-code">국가명 검색 (예: Korea, United):</label>
    <input type="text" id="iso-code" placeholder="국가명을 입력하세요">
    <button id="submit-btn">검색</button>
    <div id="results"></div>
  </div>

  <!-- Three.js 및 관련 모듈 로드 (로컬 파일 사용) -->
  <script type="module">
    import * as THREE from './libs/three.module.js';
    import { OrbitControls } from './libs/OrbitControls.js';
    import TWEEN from './libs/tween.esm.js';

    let scene, camera, renderer, controls;
    let globeMesh;
    let koreaBoundaryLine = null;      // 대한민국 경계선 (파란색)
    let currentBoundaryLine = null;     // 선택된 다른 국가 경계선 (빨간색)
    let countryGeoJSON = null;
    const globeRadius = 1;

    // 공식 국가명을 반환하는 헬퍼 함수 (GeoJSON의 ADMIN 프로퍼티 사용)
    function getCountryName(feature) {
      return feature.properties.ADMIN;
    }

    // 위도/경도를 3D 좌표로 변환 (지구본 좌표계)
    function latLonToXYZ(lat, lon, radius = globeRadius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      const y = radius * Math.cos(phi);
      return new THREE.Vector3(x, y, z);
    }

    // 초기화: 씬, 카메라, 렌더러, OrbitControls, 지구본 생성
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.panSpeed = 1.0;
      camera.position.set(2, 2, 2);
      controls.update();

      // 텍스처를 입힌 지구본 생성
      const sphereGeometry = new THREE.SphereGeometry(globeRadius, 64, 64);
      const textureLoader = new THREE.TextureLoader();
      const texture = textureLoader.load('eo_base_2020_clean_geo.jpg');
      const sphereMaterial = new THREE.MeshBasicMaterial({ map: texture });
      globeMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
      scene.add(globeMesh);

      // GeoJSON 데이터 로드 (국가 경계)
      fetch('countries.geojson')
        .then(response => response.json())
        .then(data => {
          countryGeoJSON = data;
          // 초기 화면 구성: "Korea" 자동 검색
          document.getElementById('iso-code').value = "Korea";
          searchCountries();
        })
        .catch(err => console.error('GeoJSON 로드 실패:', err));

      animate();
    }

    // 애니메이션 루프: TWEEN 업데이트, OrbitControls 업데이트 및 렌더링
    function animate(time) {
      requestAnimationFrame(animate);
      TWEEN.update(time);
      
      // 줌인 상태에 따른 panSpeed 동적 조정
      const distance = camera.position.length();
      if (distance < 2.5) {
        controls.panSpeed = 0.3;
      } else if (distance < 4) {
        controls.panSpeed = 0.6;
      } else {
        controls.panSpeed = 1.0;
      }
      
      controls.update();
      renderer.render(scene, camera);
    }

    // 검색어를 기반으로 국가 목록을 찾아 결과를 표시
    function searchCountries() {
      const searchTerm = document.getElementById('iso-code').value.trim().toLowerCase();
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = ""; // 기존 결과 초기화
      
      if (!countryGeoJSON) {
        alert("GeoJSON 데이터가 아직 로드되지 않았습니다.");
        return;
      }
      
      // 공식 국가명(ADMIN)에서 검색어가 포함된 국가 찾기 (부분 검색)
      const matches = countryGeoJSON.features.filter(feature => {
        const name = getCountryName(feature).toLowerCase();
        return name.indexOf(searchTerm) !== -1;
      });
      
      if (matches.length === 0) {
        resultsDiv.innerHTML = "<div>검색 결과가 없습니다.</div>";
        return;
      }
      
      // 결과 목록 표시
      matches.forEach(feature => {
        const div = document.createElement('div');
        div.className = "result-item";
        div.textContent = getCountryName(feature) + " (" + feature.properties.ISO_A3 + ")";
        div.addEventListener('click', () => {
          // 클릭 시 해당 국가 선택 후 경계선 표시
          displayCountry(feature);
          resultsDiv.innerHTML = ""; // 목록 닫기
          document.getElementById('iso-code').value = getCountryName(feature);
        });
        resultsDiv.appendChild(div);
      });
    }

    // 선택된 국가의 경계선을 그리고 카메라 이동
    function displayCountry(feature) {
      // Polygon 또는 MultiPolygon (외부 링만 사용)
      let coordinates = [];
      if (feature.geometry.type === "Polygon") {
        coordinates = feature.geometry.coordinates[0];
      } else if (feature.geometry.type === "MultiPolygon") {
        coordinates = feature.geometry.coordinates[0][0];
      } else {
        alert("알 수 없는 지오메트리 타입: " + feature.geometry.type);
        return;
      }
      
      // 좌표를 3D 포인트로 변환
      const points = [];
      coordinates.forEach(coord => {
        const lon = coord[0], lat = coord[1];
        points.push(latLonToXYZ(lat, lon, globeRadius + 0.005));
      });
      if (!points[0].equals(points[points.length - 1])) {
        points.push(points[0]);
      }
      
      // 경계선 색상: 대한민국(KOR)은 파란색, 그 외는 빨간색
      const isoCode = feature.properties.ISO_A3;
      const lineColor = isoCode === "KOR" ? 0x0000ff : 0xff0000;
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: lineColor });
      const newBoundaryLine = new THREE.Line(geometry, material);
      
      // 대한민국 경계선은 koreaBoundaryLine에 저장, 나머지는 currentBoundaryLine에 저장
      if (isoCode === "KOR") {
        if (koreaBoundaryLine) {
          scene.remove(koreaBoundaryLine);
          koreaBoundaryLine.geometry.dispose();
          koreaBoundaryLine.material.dispose();
        }
        koreaBoundaryLine = newBoundaryLine;
        scene.add(koreaBoundaryLine);
      } else {
        if (currentBoundaryLine) {
          scene.remove(currentBoundaryLine);
          currentBoundaryLine.geometry.dispose();
          currentBoundaryLine.material.dispose();
        }
        currentBoundaryLine = newBoundaryLine;
        scene.add(currentBoundaryLine);
      }
      
      // 국가 중심 계산
      const center = new THREE.Vector3();
      points.forEach(p => center.add(p));
      center.divideScalar(points.length);
      
      // 카메라 이동: 선택한 국가 중심의 2.2배 떨어진 위치로 이동
      const newCameraPos = center.clone().multiplyScalar(2.2);
      new TWEEN.Tween(camera.position)
        .to({ x: newCameraPos.x, y: newCameraPos.y, z: newCameraPos.z }, 1000)
        .easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
          // 회전 중심은 (0,0,0)으로 설정하여 자유로운 회전 가능
          controls.target.set(0, 0, 0);
        })
        .start();
    }

    // 버튼 클릭 시 검색 수행
    document.getElementById('submit-btn').addEventListener('click', searchCountries);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    window.onload = init;
  </script>
</body>
</html>
