<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>인터랙티브 3D 지구본 (Three.js GitHub Pages 버전)</title>
  <!-- 임시로 CSP에서 unsafe-inline 허용 (운영 환경에서는 nonce나 해시 적용 권장) -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <!-- 사용자 인터페이스 -->
  <div id="overlay">
    <label for="iso-code">ISO_A3 코드 입력 (예: USA, CHN, KOR):</label>
    <input type="text" id="iso-code" placeholder="Enter Country Code">
    <button id="submit-btn">국가 선택</button>
  </div>

  <!-- Three.js 및 관련 모듈 로드 (로컬 파일 사용) -->
  <script type="module">
    import * as THREE from './libs/three.module.js';
    import { OrbitControls } from './libs/OrbitControls.js';
    import TWEEN from './libs/tween.esm.js';

    let scene, camera, renderer, controls;
    let globeMesh;
    let koreaBoundaryLine = null;      // 대한민국 경계선 (파란색)
    let currentBoundaryLine = null;     // 검색한 다른 국가의 경계선 (빨간색)
    let countryGeoJSON = null;
    const globeRadius = 1;

    // 위도/경도를 3D 좌표로 변환 (지구본 좌표계)
    function latLonToXYZ(lat, lon, radius = globeRadius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      const y = radius * Math.cos(phi);
      return new THREE.Vector3(x, y, z);
    }

    // 초기화: 씬, 카메라, 렌더러, OrbitControls, 지구본 생성
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.panSpeed = 1.0;
      camera.position.set(2, 2, 2);
      controls.update();

      // 텍스처를 입힌 지구본 생성
      const sphereGeometry = new THREE.SphereGeometry(globeRadius, 64, 64);
      const textureLoader = new THREE.TextureLoader();
      const texture = textureLoader.load('eo_base_2020_clean_geo.jpg');
      const sphereMaterial = new THREE.MeshBasicMaterial({ map: texture });
      globeMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
      scene.add(globeMesh);

      // GeoJSON 데이터 로드 (국가 경계)
      fetch('countries.geojson')
        .then(response => response.json())
        .then(data => {
          countryGeoJSON = data;
          // 초기 화면 구성: "KOR" 자동 검색
          document.getElementById('iso-code').value = "KOR";
          updateCountryGlobe(); // 대한민국 경계선이 koreaBoundaryLine으로 설정됨
        })
        .catch(err => console.error('GeoJSON 로드 실패:', err));

      animate();
    }

    // 애니메이션 루프: TWEEN 업데이트, OrbitControls 업데이트 및 렌더링
    function animate(time) {
      requestAnimationFrame(animate);
      TWEEN.update(time);

      // 줌인 상태에 따른 panSpeed 동적 조정
      const distance = camera.position.length();
      if (distance < 2.5) {
        controls.panSpeed = 0.3;
      } else if (distance < 4) {
        controls.panSpeed = 0.6;
      } else {
        controls.panSpeed = 1.0;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    // ISO_A3 코드에 해당하는 국가 경계선을 표시하고 카메라 이동
    function updateCountryGlobe() {
      const isoCode = document.getElementById('iso-code').value.trim().toUpperCase();
      if (!isoCode) return;
      
      if (!countryGeoJSON) {
        alert("GeoJSON 데이터가 아직 로드되지 않았습니다.");
        return;
      }
      
      // ISO_A3 코드에 해당하는 국가 찾기
      let feature = null;
      for (const f of countryGeoJSON.features) {
        if (f.properties.ISO_A3 === isoCode) {
          feature = f;
          break;
        }
      }
      if (!feature) {
        alert("해당 국가 경계 데이터를 찾을 수 없습니다: " + isoCode);
        return;
      }
      
      // Polygon 또는 MultiPolygon (외부 링만 사용)
      let coordinates = [];
      if (feature.geometry.type === "Polygon") {
        coordinates = feature.geometry.coordinates[0];
      } else if (feature.geometry.type === "MultiPolygon") {
        coordinates = feature.geometry.coordinates[0][0];
      } else {
        alert("알 수 없는 지오메트리 타입: " + feature.geometry.type);
        return;
      }
      
      // 좌표를 3D 포인트로 변환
      const points = [];
      coordinates.forEach(coord => {
        const lon = coord[0], lat = coord[1];
        points.push(latLonToXYZ(lat, lon, globeRadius + 0.005));
      });
      if (!points[0].equals(points[points.length - 1])) {
        points.push(points[0]);
      }
      
      // 경계선 색상: 대한민국은 파란색, 그 외는 빨간색
      const lineColor = isoCode === "KOR" ? 0x0000ff : 0xff0000;
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: lineColor });
      const newBoundaryLine = new THREE.Line(geometry, material);
      
      // 만약 검색한 국가가 "KOR"이면 koreaBoundaryLine 업데이트 (기존 있으면 교체)
      // 다른 국가 검색 시에는 기존 currentBoundaryLine 제거 후 새로 추가하되, koreaBoundaryLine은 그대로 남김
      if (isoCode === "KOR") {
        if (koreaBoundaryLine) {
          scene.remove(koreaBoundaryLine);
          koreaBoundaryLine.geometry.dispose();
          koreaBoundaryLine.material.dispose();
        }
        koreaBoundaryLine = newBoundaryLine;
        scene.add(koreaBoundaryLine);
      } else {
        if (currentBoundaryLine) {
          scene.remove(currentBoundaryLine);
          currentBoundaryLine.geometry.dispose();
          currentBoundaryLine.material.dispose();
        }
        currentBoundaryLine = newBoundaryLine;
        scene.add(currentBoundaryLine);
      }
      
      // 국가 중심 계산
      const center = new THREE.Vector3();
      points.forEach(p => center.add(p));
      center.divideScalar(points.length);
      
      // 카메라 이동: 검색한 국가 중심의 2.2배 떨어진 위치로 이동
      const newCameraPos = center.clone().multiplyScalar(2.2);
      new TWEEN.Tween(camera.position)
        .to({ x: newCameraPos.x, y: newCameraPos.y, z: newCameraPos.z }, 1000)
        .easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
          // 회전 중심은 전역 중심(0,0,0)으로 설정하여 자유로운 회전 가능
          controls.target.set(0, 0, 0);
        })
        .start();
    }
    
    document.getElementById('submit-btn').addEventListener('click', updateCountryGlobe);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    window.onload = init;
  </script>
</body>
</html>
