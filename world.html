<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>인터랙티브 3D 지구본 (국가 경계 내부를 국기로 채우기)</title>
  <!-- 개발 편의를 위한 CSP (운영 시 nonce/hash 사용 권장) -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      max-width: 300px;
    }
    #results {
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
    }
    .result-item {
      padding: 5px;
      border-bottom: 1px solid #ccc;
      cursor: pointer;
    }
    .result-item:hover {
      background-color: #eee;
    }
  </style>
</head>
<body>
  <!-- 사용자 인터페이스 -->
  <div id="overlay">
    <label for="iso-code">국가명 검색 (예: Korea, United):</label>
    <input type="text" id="iso-code" placeholder="국가명을 입력하세요">
    <button id="submit-btn">검색</button>
    <div id="results"></div>
  </div>

  <!-- Three.js 및 관련 모듈 로드 -->
  <script type="module">
    import * as THREE from './libs/three.module.js';
    import { OrbitControls } from './libs/OrbitControls.js';
    import TWEEN from './libs/tween.esm.js';
    import { Earcut } from './libs/Earcut.js'; // <-- 추가 (three/examples/jsm/utils/Earcut.js)

    let scene, camera, renderer, controls;
    let globeMesh;
    let countryGeoJSON = null;
    const globeRadius = 1;

    // 기존: 국경선(Line)만 그렸던 객체들
    let koreaBoundaryLine = null;      
    let currentBoundaryLine = null;

    // 새로 추가: 국기 텍스처가 입혀진 폴리곤 Mesh
    let koreaFlagMesh = null;
    let currentFlagMesh = null;

    // ISO2 코드로 추정되는 속성 (GeoJSON상 ISO_A2, ISO_A3 등 다양)
    // 실제 데이터에 맞춰 수정 필요
    function getISO2(feature) {
      // 예: GeoJSON에 ISO_A2가 있다면 그걸 사용
      // 없으면 ISO_A3 등 다른 필드에서 변환
      // 여기서는 ISO_A2가 있다고 가정
      const iso2 = feature.properties.ISO_A2;
      if (!iso2) return null;
      return iso2.trim();
    }

    // 공식 국가명 (ADMIN 필드)
    function getCountryName(feature) {
      return feature.properties.ADMIN;
    }

    // 위도/경도를 3D 좌표로 변환 (지구본 좌표계)
    function latLonToXYZ(lat, lon, radius = globeRadius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const z =  radius * Math.sin(phi) * Math.sin(theta);
      const y =  radius * Math.cos(phi);
      return new THREE.Vector3(x, y, z);
    }

    // 초기화
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.panSpeed = 1.0;
      camera.position.set(2, 2, 2);
      controls.update();

      // 지구본(구)에 텍스처 입힘
      const sphereGeometry = new THREE.SphereGeometry(globeRadius, 64, 64);
      const textureLoader = new THREE.TextureLoader();
      const texture = textureLoader.load('eo_base_2020_clean_geo_optimized.jpg');
      const sphereMaterial = new THREE.MeshBasicMaterial({ map: texture });
      globeMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
      scene.add(globeMesh);

      // GeoJSON 로드
      fetch('countries.geojson')
        .then(response => response.json())
        .then(data => {
          countryGeoJSON = data;
          // 초기 검색 예시
          document.getElementById('iso-code').value = "Korea";
          searchCountries();
        })
        .catch(err => console.error('GeoJSON 로드 실패:', err));

      animate();
    }

    // 애니메이션 루프
    function animate(time) {
      requestAnimationFrame(animate);
      TWEEN.update(time);

      // 카메라 거리 따라 panSpeed 조절 (옵션)
      const distance = camera.position.length();
      if (distance < 2.5) {
        controls.panSpeed = 0.3;
      } else if (distance < 4) {
        controls.panSpeed = 0.6;
      } else {
        controls.panSpeed = 1.0;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    // 검색 버튼 동작
    function searchCountries() {
      const searchTerm = document.getElementById('iso-code').value.trim().toLowerCase();
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = "";

      if (!countryGeoJSON) {
        alert("GeoJSON 데이터가 아직 로드되지 않았습니다.");
        return;
      }

      // 국가명(ADMIN) 소문자로 변환하여 부분 검색
      const matches = countryGeoJSON.features.filter(feature => {
        const name = getCountryName(feature).toLowerCase();
        return name.indexOf(searchTerm) !== -1;
      });

      if (matches.length === 0) {
        resultsDiv.innerHTML = "<div>검색 결과가 없습니다.</div>";
        return;
      }

      if (matches.length === 1) {
        displayCountry(matches[0]);
        resultsDiv.innerHTML = "";
      } else {
        matches.forEach(feature => {
          const div = document.createElement('div');
          div.className = "result-item";
          const iso2 = getISO2(feature) || "??";
          div.textContent = getCountryName(feature) + " (" + iso2 + ")";
          div.addEventListener('click', () => {
            displayCountry(feature);
            resultsDiv.innerHTML = "";
            document.getElementById('iso-code').value = getCountryName(feature);
          });
          resultsDiv.appendChild(div);
        });
      }
    }

    // 국가 표시(경계선 + 국기 폴리곤 + 카메라 이동)
    function displayCountry(feature) {
      // Polygon or MultiPolygon
      let coordinates;
      if (feature.geometry.type === "Polygon") {
        // 가장 바깥 경계만 사용 (feature.geometry.coordinates[0])
        coordinates = feature.geometry.coordinates[0];
      } else if (feature.geometry.type === "MultiPolygon") {
        // MultiPolygon의 첫 번째 폴리곤 외곽만
        coordinates = feature.geometry.coordinates[0][0];
      } else {
        alert("지원하지 않는 지오메트리 타입: " + feature.geometry.type);
        return;
      }

      // 경계선(Line) 생성(기존 로직)
      drawBoundaryLine(feature, coordinates);

      // 국기 폴리곤 Mesh 생성
      const iso2 = getISO2(feature) || "??"; 
      drawFlagPolygon(feature, coordinates, iso2);

      // 폴리곤 중심(대략)을 구해 카메라 이동
      const points3D = coordinates.map(coord => {
        const lon = coord[0], lat = coord[1];
        return latLonToXYZ(lat, lon, globeRadius + 0.005);
      });
      const center = new THREE.Vector3();
      points3D.forEach(p => center.add(p));
      center.divideScalar(points3D.length);

      // 카메라를 그 지점 부근으로 이동
      const newCameraPos = center.clone().multiplyScalar(2.2);
      new TWEEN.Tween(camera.position)
        .to({ x: newCameraPos.x, y: newCameraPos.y, z: newCameraPos.z }, 1000)
        .easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
          controls.target.set(0, 0, 0); // 회전 중심은 지구 중심
        })
        .start();
    }

    // 1) 경계선(Line)만 그리는 함수 (기존)
    function drawBoundaryLine(feature, coordinates) {
      const isoCode = feature.properties.ISO_A3; // KOR, USA 등
      const lineColor = (isoCode === "KOR") ? 0x0000ff : 0xff0000;

      // 3D 좌표 변환
      const points = coordinates.map(coord => {
        const lon = coord[0], lat = coord[1];
        return latLonToXYZ(lat, lon, globeRadius + 0.005);
      });
      // 닫힌 경계 (마지막 점이 첫 점과 동일) 보정
      if (!points[0].equals(points[points.length - 1])) {
        points.push(points[0]);
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: lineColor });
      const newBoundaryLine = new THREE.Line(geometry, material);

      // KOR 경계선 / 그 외 경계선
      if (isoCode === "KOR") {
        if (koreaBoundaryLine) {
          scene.remove(koreaBoundaryLine);
          koreaBoundaryLine.geometry.dispose();
          koreaBoundaryLine.material.dispose();
        }
        koreaBoundaryLine = newBoundaryLine;
        scene.add(koreaBoundaryLine);
      } else {
        if (currentBoundaryLine) {
          scene.remove(currentBoundaryLine);
          currentBoundaryLine.geometry.dispose();
          currentBoundaryLine.material.dispose();
        }
        currentBoundaryLine = newBoundaryLine;
        scene.add(currentBoundaryLine);
      }
    }

    // 2) 국기 폴리곤(면)을 그려주는 함수
    function drawFlagPolygon(feature, coordinates, iso2) {
      // 일단 Polygon 외곽만 처리 (Hole이나 MultiPolygon은 생략)
      // lat/lon의 최소·최대값 구하기
      let minLat =  90, maxLat = -90;
      let minLon = 180, maxLon = -180;
      coordinates.forEach(coord => {
        const [lon, lat] = coord;
        if (lat < minLat) minLat = lat;
        if (lat > maxLat) maxLat = lat;
        if (lon < minLon) minLon = lon;
        if (lon > maxLon) maxLon = lon;
      });

      // 폴리곤을 "2D 평면(lat-lon)"에 펼쳐서 ShapeGeometry 생성
      //  - x축: lon, y축: lat 로 간주
      //  - uv는 (lon, lat)를 (0~1) 범위로 정규화
      const shapePoints2D = coordinates.map(coord => {
        const [lon, lat] = coord;
        return new THREE.Vector2(lon, lat);
      });
      // shapePoints2D 마지막 점이 첫 점과 같으면 제거
      if (shapePoints2D[0].equals(shapePoints2D[shapePoints2D.length - 1])) {
        shapePoints2D.pop();
      }

      // three.js에서 Shape를 만들기 위해서는
      //  1) Shape 인스턴스에 moveTo, lineTo 로 점 추가
      //  2) triangulateShape로 지오메트리 생성
      const shape = new THREE.Shape();
      shape.moveTo(shapePoints2D[0].x, shapePoints2D[0].y);
      for (let i = 1; i < shapePoints2D.length; i++) {
        shape.lineTo(shapePoints2D[i].x, shapePoints2D[i].y);
      }

      // 폴리곤 내부를 Earcut로 삼각분할
      const shapeGeometry = new THREE.ShapeGeometry(shape);
      // 이제 shapeGeometry의 position 속성(x=lon, y=lat)을 이용해 구면 좌표 & uv 매핑을 해야 함

      // (A) UV 좌표 계산: lon, lat → 0~1 범위
      const uvArray = [];
      const posAttr = shapeGeometry.getAttribute('position');
      for (let i = 0; i < posAttr.count; i++) {
        const lon = posAttr.getX(i);
        const lat = posAttr.getY(i);
        // uv.x: (lon - minLon)/(maxLon - minLon)
        // uv.y: (lat - minLat)/(maxLat - minLat)
        const u = (lon - minLon) / (maxLon - minLon);
        const v = (lat - minLat) / (maxLat - minLat);
        uvArray.push(u, v);
      }
      shapeGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvArray, 2));

      // (B) 폴리곤을 실제 구면 좌표로 이동
      //     position에 들어있는 (lon, lat)를 latLonToXYZ로 변환
      for (let i = 0; i < posAttr.count; i++) {
        const lon = posAttr.getX(i);
        const lat = posAttr.getY(i);
        const v3 = latLonToXYZ(lat, lon, globeRadius + 0.002); 
        // 약간 띄워서(z-fighting 방지)
        posAttr.setXYZ(i, v3.x, v3.y, v3.z);
      }
      posAttr.needsUpdate = true;

      // 국기 텍스처 로드 (확장자 우선순위 .gif → .png → .jpg → .bmp)
      loadFlagTexture(iso2).then(flagTexture => {
        // 이전에 그려진 폴리곤 제거
        removeOldFlagMesh(iso2);

        // 새 재질(메쉬) 생성
        const flagMaterial = new THREE.MeshBasicMaterial({
          map: flagTexture,
          side: THREE.DoubleSide, // 양면 렌더링
          transparent: true
        });
        const countryFlagMesh = new THREE.Mesh(shapeGeometry, flagMaterial);

        // 장면에 추가
        if (iso2 === "KR") {
          // 대한민국(KR)이라면 koreaFlagMesh
          if (koreaFlagMesh) scene.remove(koreaFlagMesh);
          koreaFlagMesh = countryFlagMesh;
          scene.add(koreaFlagMesh);
        } else {
          if (currentFlagMesh) scene.remove(currentFlagMesh);
          currentFlagMesh = countryFlagMesh;
          scene.add(currentFlagMesh);
        }
      }).catch(err => {
        console.warn("국기 로드 실패:", err);
      });
    }

    // 이전에 그려진 폴리곤 Mesh 제거
    function removeOldFlagMesh(iso2) {
      if (iso2 === "KR") {
        if (koreaFlagMesh) {
          scene.remove(koreaFlagMesh);
          koreaFlagMesh.geometry.dispose();
          koreaFlagMesh.material.dispose();
          koreaFlagMesh = null;
        }
      } else {
        if (currentFlagMesh) {
          scene.remove(currentFlagMesh);
          currentFlagMesh.geometry.dispose();
          currentFlagMesh.material.dispose();
          currentFlagMesh = null;
        }
      }
    }

    // 국기 텍스처 로드 함수
    // ./flag/{iso2}.{확장자} 순서대로 시도
    function loadFlagTexture(iso2) {
      return new Promise((resolve, reject) => {
        if (iso2 === "??") {
          return reject("ISO2 코드가 없어 국기 이미지를 찾을 수 없음");
        }
        const exts = ['gif','png','jpg','bmp'];
        const basePath = './flag/';
        const loader = new THREE.TextureLoader();

        function tryLoad(index) {
          if (index >= exts.length) {
            reject(`모든 확장자를 시도했으나 ${iso2} 국기 파일 없음`);
            return;
          }
          const url = `${basePath}${iso2}.${exts[index]}`;
          loader.load(
            url,
            (texture) => {
              resolve(texture);
            },
            undefined,
            () => {
              // 로드 실패 시 다음 확장자 시도
              tryLoad(index + 1);
            }
          );
        }
        tryLoad(0);
      });
    }

    // 이벤트
    document.getElementById('submit-btn').addEventListener('click', searchCountries);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.onload = init;
  </script>
</body>
</html>
